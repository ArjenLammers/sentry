{"version":3,"file":"offline.js","sourceRoot":"","sources":["../src/offline.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { Event, EventProcessor, Hub, Integration } from '@sentry/types';\nimport { getGlobalObject, logger, uuid4 } from '@sentry/utils';\nimport * as localForageType from 'localforage';\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst localForage = require('localforage');\n/**\n * cache offline errors and send when connected\n */\nexport class Offline implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Offline';\n\n  /**\n   * @inheritDoc\n   */\n  public readonly name: string = Offline.id;\n\n  /**\n   * the global instance\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public global: any;\n\n  /**\n   * the current hub instance\n   */\n  public hub?: Hub;\n\n  /**\n   * maximum number of events to store while offline\n   */\n  public maxStoredEvents: number;\n\n  /**\n   * event cache\n   */\n  public offlineEventStore: typeof localForageType; // type imported from localforage\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { maxStoredEvents?: number } = {}) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.global = getGlobalObject<any>();\n    this.maxStoredEvents = options.maxStoredEvents || 30; // set a reasonable default\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    this.offlineEventStore = localForage.createInstance({\n      name: 'sentry/offlineEventStore',\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this.hub = getCurrentHub();\n\n    if ('addEventListener' in this.global) {\n      this.global.addEventListener('online', () => {\n        this._sendEvents().catch(() => {\n          logger.warn('could not send cached events');\n        });\n      });\n    }\n\n    addGlobalEventProcessor((event: Event) => {\n      if (this.hub && this.hub.getIntegration(Offline)) {\n        // cache if we are positively offline\n        if ('navigator' in this.global && 'onLine' in this.global.navigator && !this.global.navigator.onLine) {\n          this._cacheEvent(event)\n            .then((_event: Event): Promise<void> => this._enforceMaxEvents())\n            .catch((_error): void => {\n              logger.warn('could not cache event while offline');\n            });\n\n          // return null on success or failure, because being offline will still result in an error\n          return null;\n        }\n      }\n\n      return event;\n    });\n\n    // if online now, send any events stored in a previous offline session\n    if ('navigator' in this.global && 'onLine' in this.global.navigator && this.global.navigator.onLine) {\n      this._sendEvents().catch(() => {\n        logger.warn('could not send cached events');\n      });\n    }\n  }\n\n  /**\n   * cache an event to send later\n   * @param event an event\n   */\n  private async _cacheEvent(event: Event): Promise<Event> {\n    return this.offlineEventStore.setItem<Event>(uuid4(), event);\n  }\n\n  /**\n   * purge excess events if necessary\n   */\n  private async _enforceMaxEvents(): Promise<void> {\n    const events: Array<{ event: Event; cacheKey: string }> = [];\n\n    return this.offlineEventStore\n      .iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n        // aggregate events\n        events.push({ cacheKey, event });\n      })\n      .then(\n        (): Promise<void> =>\n          // this promise resolves when the iteration is finished\n          this._purgeEvents(\n            // purge all events past maxStoredEvents in reverse chronological order\n            events\n              .sort((a, b) => (b.event.timestamp || 0) - (a.event.timestamp || 0))\n              .slice(this.maxStoredEvents < events.length ? this.maxStoredEvents : events.length)\n              .map(event => event.cacheKey),\n          ),\n      )\n      .catch((_error): void => {\n        logger.warn('could not enforce max events');\n      });\n  }\n\n  /**\n   * purge event from cache\n   */\n  private async _purgeEvent(cacheKey: string): Promise<void> {\n    return this.offlineEventStore.removeItem(cacheKey);\n  }\n\n  /**\n   * purge events from cache\n   */\n  private async _purgeEvents(cacheKeys: string[]): Promise<void> {\n    // trail with .then to ensure the return type as void and not void|void[]\n    return Promise.all(cacheKeys.map(cacheKey => this._purgeEvent(cacheKey))).then();\n  }\n\n  /**\n   * send all events\n   */\n  private async _sendEvents(): Promise<void> {\n    return this.offlineEventStore.iterate<Event, void>((event: Event, cacheKey: string, _index: number): void => {\n      if (this.hub) {\n        this.hub.captureEvent(event);\n\n        this._purgeEvent(cacheKey).catch((_error): void => {\n          logger.warn('could not purge event from cache');\n        });\n      } else {\n        logger.warn('no hub found - could not send cached event');\n      }\n    });\n  }\n}\n"]}