{"version":3,"file":"File.js","sourceRoot":"","sources":["../../../lib/Helper/File.ts"],"names":[],"mappings":";;AAAA,uBAAyB;AACzB,IAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAE7B,IAAM,cAAc,GAAG,CAAC,iBAAiB,EAAE,aAAa,EAAE,YAAY,CAAC,CAAC;AAExE,SAAgB,iBAAiB,CAC/B,WAAmB,EACnB,IAAS;IACT,cAAc;SAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;QAAd,6BAAc;;IAEd,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,EAAE,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,OAAO,CAAC,OAAO,CAAC,UAAC,KAAa;QAC5B,IAAM,QAAQ,GAAG,EAAE,CAAC,YAAY,CAAC,KAAK,EAAE;YACtC,QAAQ,EAAE,OAAO;SAClB,CAAC,CAAC;QACH,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,cAAM,OAAA,IAAI,gBAAC,QAAQ,EAAE,KAAK,SAAK,IAAI,IAA7B,CAA8B,CAAC,CAAC,IAAI,CAAC,UAAA,WAAW;YACjE,IACE,WAAW,KAAK,IAAI;gBACpB,QAAQ,KAAK,SAAS;gBACtB,QAAQ,KAAK,WAAW,EACxB;gBACA,EAAE,CAAC,aAAa,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;aACtC;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,EAAE,CAAC;AACZ,CAAC;AAxBD,8CAwBC;AAED,SAAgB,MAAM,CAAC,WAAmB;IACxC,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,OAAO,CAAC,MAAM,CAAC,UAAC,IAAa,EAAE,KAAa;QACjD,OAAO,IAAI,IAAI,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC,EAAE,IAAI,CAAC,CAAC;AACX,CAAC;AAVD,wBAUC;AAED,SAAgB,cAAc,CAC5B,WAAmB,EACnB,cAAsB;IAEtB,IAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QACrC,MAAM,EAAE,cAAc;KACvB,CAAC,CAAC;IACH,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,OAAO,CAAC,MAAM,CAAC,UAAC,IAAa,EAAE,KAAa;QACjD,OAAO,CACL,IAAI;YACJ,EAAE;iBACC,YAAY,CAAC,KAAK,CAAC;iBACnB,QAAQ,EAAE;iBACV,KAAK,CAAC,cAAc,CAAC,CACzB,CAAC;IACJ,CAAC,EAAE,IAAI,CAAC,CAAC;AACX,CAAC;AAnBD,wCAmBC","sourcesContent":["import * as fs from 'fs';\nconst glob = require('glob');\n\nconst IGNORE_PATTERN = ['node_modules/**', 'ios/Pods/**', '**/Pods/**'];\n\nexport function patchMatchingFile(\n  globPattern: string,\n  func: any,\n  ...args: any[]\n): Promise<void> {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  let rv = Promise.resolve();\n  matches.forEach((match: string) => {\n    const contents = fs.readFileSync(match, {\n      encoding: 'utf-8',\n    });\n    rv = rv.then(() => func(contents, match, ...args)).then(newContents => {\n      if (\n        newContents !== null &&\n        contents !== undefined &&\n        contents !== newContents\n      ) {\n        fs.writeFileSync(match, newContents);\n      }\n    });\n  });\n  return rv;\n}\n\nexport function exists(globPattern: string): boolean {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  if (matches.length === 0) {\n    return false;\n  }\n  return matches.reduce((prev: boolean, match: string) => {\n    return prev && fs.existsSync(match);\n  }, true);\n}\n\nexport function matchesContent(\n  globPattern: string,\n  contentPattern: RegExp,\n): boolean {\n  const matches = glob.sync(globPattern, {\n    ignore: IGNORE_PATTERN,\n  });\n  if (matches.length === 0) {\n    return false;\n  }\n  return matches.reduce((prev: boolean, match: string) => {\n    return (\n      prev &&\n      fs\n        .readFileSync(match)\n        .toString()\n        .match(contentPattern)\n    );\n  }, true);\n}\n"]}